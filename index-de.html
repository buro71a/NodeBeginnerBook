<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link href="prettify/prettify.css" type="text/css" rel="stylesheet" />

		<title>Das Node Einsteigerhandbuch » Eine umfassende Einführung in node.js</title>
		<meta name="description" content="A comprehensive Node.js tutorial for beginners: Learn how to build a full blown web application with server-side JavaScript" />

		<style type="text/css">
			body {font-family: Georgia, serif;background-color: #eee;padding-top: 0px;-webkit-text-size-adjust: auto;
			}

			#book, #donate, #disqus_thread, #footer, #workinprogressnote {width: 640px;margin: 0 auto;margin-top: 24px;margin-bottom: 100px;padding: 64px;background-color: white;border-top: 1px solid #ddd;border-left: 1px solid #ddd;border-bottom: 1px solid #ddd;border-right: 1px solid #ddd;z-index: 100;
-moz-box-shadow: 14px 11px 27px #888;-webkit-box-shadow: 14px 11px 27px #888;box-shadow: 14px 11px 27px #888;
			}

			#book {margin-top: 124px;
			}

			#author {margin-top: -41px;margin-left: 279px;color: #888;font-family: "Helvetica Neue", sans-serif;font-size: 75%;
			}

			#updateinfo {margin-top: -1px;margin-left: 279px;color: #bbb;font-family: "Helvetica Neue", sans-serif;font-size: 75%;
			}

			#workinprogressnote p {font-family: "Helvetica Neue", sans-serif;color: #700;text-align: center;
			}

			#buy-the-ebook, #translations {font-family: "Helvetica Neue", sans-serif;font-size: 13px;color: #fff;text-align: center;padding: 8px;padding-left: 32px;padding-right: 32px;border-radius: 8px;-moz-border-radius: 8px;-webkit-border-radius: 8px;box-shadow: 0px 0px 4px #444;-moz-box-shadow: 0px 0px 4px #444;-webkit-box-shadow: 0px 0px 4px #444;position: relative;margin-bottom: 20px;margin-left: auto;margin-right: auto;width: 704px;background-color: #555;
			}

			#translations a {text-decoration: none;color: #fff;
			}

			#translations .flag {display: inline-block;vertical-align: middle;padding-top: 4px;
			}
			#translations .text {display: inline-block;vertical-align: middle;margin-right: 24px;
			}

			#buy-the-ebook {padding-bottom: 20px;
			}

			#buy-the-ebook .headline {font-size: 24pt;font-weight: bold;padding-bottom: 16px;
			}

			#buy-the-ebook .cover {width: 131px;display: table-cell;padding-right: 0px;padding-left: 40px;vertical-align: bottom;align: center;color: #bbb;
			}

			#buy-the-ebook .cover img {border: 1px solid black;box-shadow: 0 1px 2px rgba(0,0,0,0.4), inset -1px 1px 0 rgba(255,255,255,0.4);-moz-box-shadow: 0 1px 2px rgba(0,0,0,0.4), inset -1px 1px 0 rgba(255,255,255,0.4);-webkit-box-shadow: 0 1px 2px rgba(0,0,0,0.4), inset -1px 1px 0 rgba(255,255,255,0.4);
			}

			#buy-the-ebook .description {width: 349px;display: table-cell;padding-right: 32px;padding-left: 0;vertical-align: top;text-align: center;
			}

			#buy-the-ebook .description ul {list-style-type: none;
			}

			#buy-the-ebook .price {width: 110px;vertical-align: middle;display: table-cell;font-size: 12pt;color: #ccc;background-color: yellow;border-radius: 60px;
			}

			#buy-the-ebook .current-price {font-size: 24pt;color: #14d014;font-weight: bolder;text-shadow: 0.0125em 0.0125em #333;
			}

			#buy-the-ebook .price a {text-decoration: none;color: darkred;
			}

			#buy-the-ebook .buy {color: #bbb;margin-left: 280px;margin-right: auto;position: relative;
			}

			#buy-the-ebook .button {padding: 8px;margin-top: 26px;width: 140px;border: 1px solid #444;border-radius: 6px;background-image: -moz-linear-gradient(top, #14d014, #029302);background-image: -webkit-gradient(linear, center top, center bottom, from(#14d014), to(#029302));box-shadow: 0 1px 2px rgba(0,0,0,0.4), inset -1px 1px 0 rgba(255,255,255,0.4);-moz-box-shadow: 0 1px 2px rgba(0,0,0,0.4), inset -1px 1px 0 rgba(255,255,255,0.4);-webkit-box-shadow: 0 1px 2px rgba(0,0,0,0.4), inset -1px 1px 0 rgba(255,255,255,0.4);
			}

			#buy-the-ebook .buttonlink {text-decoration: none;font-weight: bold;font-size: 24px;color: #fff;text-shadow: 0.05em 0.03em #333;
			}

			#donate p {font-family: "Helvetica Neue", sans-serif;text-align: center;
			}

			#flattr {padding-top: 20px;margin-left: 183px;margin-right: 18px;text-align: center;align: left;display: inline-block;width: 100px;
			}

			#paypal {display: inline-block;margin-top: 24px;text-align: center;vertical-align: top;
			}

			#paypal fieldset {border: 0;
			}

			#disqus_thread {font-family: "Helvetica Neue", sans-serif;
			}

			#footer {font-family: "Helvetica Neue", sans-serif;background-color: #f5f5f5;margin-top: 100px;
			}

			#footer p {text-align: center;font-family: "Helvetica Neue", sans-serif;font-size: 11px;
			}

			#ccimage {float: left;margin-left: 30px;margin-right: 0;margin-top: 20px;
			}

			#praise {position: absolute;top: 120px;right: 40px;width: 204px;font-style: italic;color: #aaa;z-index: -1;text-align: right;
			}

			#praise .praise {margin-bottom: 25px;
			}

			#praise .author {font-style: normal;font-size: 75%;
			}

			#table-of-contents-headline {margin-top: 48px;color: #700;font-size: 160%;font-weight: bold;
			}

			#book #table-of-contents {margin-left: -24px;
			}

			#book #table-of-contents ul li {font-size: 100%;margin-left: 0;list-style-type: none;
			}

			#book #table-of-contents ul {padding-left: 24px;margin-top: 12px;margin-left: 0;margin-bottom: 36px;
			}

			h1 {margin-left: -63px;margin-top: -109px;font-size: 300%;color: #700;font-style: italic;
    			font-weight: bold;-webkit-text-size-adjust: 100%;
			}

			h2 {margin-top: 64px;font-size: 180%;
			}

			h3 {font-size: 160%;
			}

			h4 {font-size: 140%;
			}

			h5 {font-size: 120%;
			}

			h3, h4, h5 {margin-top: 36px;
			}

			h2, h3, h4, h5 {color: #700;font-weight: bold;margin-bottom: 36px;
			}

			#book p {text-align: justify;font-size: 110%;line-height: 150%;margin-bottom: 48px;
    			margin-top: -22px;
			}

			pre {background-color: #f7f7f7;border: 1px solid #eee;padding: 16px;margin-bottom: 64px;margin-top: -24px;font-size: 14px;
			}

			pre.prettyprint {background-color: #f7f7f7;border: 1px solid #eee;padding: 16px;margin-bottom: 64px;margin-top: -24px;font-size: 14px;
			}

			#book ul {margin-top: -24px;margin-bottom: 64px;
			}

			ul li {margin-bottom: 12px;font-size: 110%;
			}

			blockquote {font-style: italic;
			}
		</style>
		<style type="text/css" media="print">
			#forkmeongithub {display: none;
			}
			#praise {display: none;
			}
		</style>

		<script type="text/javascript" src="mootools-core-1.3.1-full-compat-yc.js"></script>
 		<script type="text/javascript" src="TOC.js"></script>
		<script type="text/javascript">
			window.addEvent('domready', function() {
    			var toc = new TOC('table-of-contents');
			});
		</script>
		<script type="text/javascript" src="prettify/prettify.js"></script>
		<script type="text/javascript">
			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-2127388-6']);
			_gaq.push(['_trackPageview']);

			(function() {var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			})();
		</script>
		<script type="text/javascript">
		/* <![CDATA[ */
			(function() {var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];s.type = 'text/javascript';s.async = true;s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto';t.parentNode.insertBefore(s, t);
			})();
		/* ]]> */
		</script>
	</head>
	<body onload="prettyPrint();">
		<div id="forkmeongithub">
			<a href="https://github.com/ManuelKiessling/NodeBeginnerBook"><img style="z-index: 5; position: absolute; top: 0; right: 0; border: 0;" src="https://d3nwyuy0nl342s.cloudfront.net/img/71eeaab9d563c2b3c590319b398dd35683265e85/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>
		</div>

		<div id="translations">
			<a href="index-de.html"><div class="flag"><img src="de-flag.png" width="24" height="24" alt="german flag" /></div><div class="text">Dieses Tutorial auf deutsch</div>
			</a>
			<a href="index-es.html"><div class="flag"><img src="es-flag.png" width="24" height="24" alt="spanish flag" /></div><div class="text">Lee este tutorial en Español</div>
			</a>
			<a href="http://www.nodebeginner.ru"><div class="flag"><img src="ru-flag.png" width="24" height="24" alt="russian flag" /></div><div class="text">Читать этот учебник на русском</div>
			</a>
		</div>

		<div id="buy-the-ebook">
			<div class="headline">Kaufen Sie das ultimative Node.js Buch-Paket!
			</div>
			<div class="cover"><a href="/buy-bundle/"><img src="the_node_beginner_book_cover.png" height="86" width="57" /></a><a href="/buy-bundle/"><img src="hands-on_node.js_cover.png" height="86" width="57" /></a>
			</div>
			<div class="description"><ul>	<li>		Einführung und Referenz in einem Paket	</li>	<li>		226 Seiten - PDF, ePub & MOBI	</li>	<li>		Direktdownload - <strong>kostenlose Updates</strong>	</li></ul>
			</div>
			<div class="price"><a href="/buy-bundle/">	<del>$10.98</del>	<div class="current-price">$7.99</div></a>
			</div>
			<div class="buy"><a class="buttonlink" href="/buy-bundle/">	<div class="button">Jetzt kaufen!</div></a>
			</div>
		</div>

		<div id="book">
			<h1>Das Node Einsteigerhandbuch</h1>
			<div id="author">Ein Node.js Tutorial von <a href="http://twitter.com/manuelkiessling">Manuel Kiessling</a> (ins Deutsche übersetzt vom <a href="http://buro71a.de/" title="Werbeagentur Büro 71a aus Würzburg">Büro 71a</a>)</div>

			<h2>Über dieses Buch</h2>

			<p>
				Das Ziel dieses Buchs ist es, Ihnen den Einstieg in die Anwendungsentwicklung mit Node.js zu vermitteln. Sie lernen während der Beispiele alles, was Sie für "anspruchsvolleres" JavaScript benötigen. Dieses Buch geht dabei weit über das typische "Hallo Welt" Tutorial hinaus!
			</p>

			<h3>Status</h3>
			<p>
				Sie lesen hier die finale Version dieses Buchs. Das heißt, es wird ausschließlich Updates geben, um Fehler zu korrigieren oder um Änderungen in Node.js Rechnung zu tragen.
			</p>
			<p>
				Die Codebeispiele in diesem Buch wurden mit Node.js Version 0.4.9 getestet.
			</p>

			<h3>Zielgruppe</h3>
			<p>
				Dieses Buch ist am passendesten für diejenigen Leser, die einen ähnlichen Hintergrund haben wie ich: Erfahrung mit mindestens einer objektorientierten Sprache wie Ruby, Python, PHP oder Java, nur wenig Erfahrung mit JavaScript und völlig ahnungslos in Sachen Node.js.
			</p>
			<p>
				Mit "Entwicklern, die bereits Erfahrung mit anderen Programmiersprachen haben" heißt vor allem, dass dieses Dokument auf wirklich grundlegende Dinge wie Datentypen, Variablen, Kontrollstrukturen und Ähnliches <em>nicht eingeht</em>. Diese Dinge sollten Ihnen bestens vertraut sein, um dieses Buch zu verstehen.
			</p>
			<p>
				Nichtsdestoweniger werden Funktionen und Objekte in JavaScript etwas detaillierter besprochen, da sie sich von Funktionen und Objekten anderer Programmiersprachen unterscheiden.
			</p>

			<h3>Aufbau dieses Buchs</h3>
			<p>
				Wenn Sie dieses Dokument vollständig gelesen haben, haben Sie eine komplette Webanwendung mit Node.js erstellt, mit der Benutzer Webseiten ansehen und Dateien hochladen können.
			</p>
			<p>
				Das ist, zugegeben, nichts wirklich Neues, aber wir werden mit ein paar zusätzlichen Umwegen nicht nur den "gerade notwendigen" Code der Anwendung schreiben, sondern ein kleines aber feines Framework schreiben, welches die verschiedenen Teilbereiche unserer Anwendung sauber trennt. Was ich damit meine, werden Sie in den nächsten Zeilen erfahren.
			</p>
			<p>
				Wir bekommen unsere Reise mit einem Überblich über die Unterschiede von Node.js im Vergleich zu JavaScript Entwicklung im Browser.
			</p>
			<p>
				Zunächst aber wollen wir einer guten, alten Tradition nachkommen - wir schreiben eine "Hallo Welt" Anwendung, was die wohl einfachste Node.js Anwendung sein dürfte, die überhaupt Arbeit verrichtet.
			</p>
			<p>
				Anschließend werden wir uns näher mit der "echten" Anwendung beschäftigen, die wir in diesem Buch schreiben wollen. Wir unterteilen die einzelnen Teilbereiche, die zum Betrieb der Anwendung nötig sind und schauen uns jeden Teilbereich Schritt für Schritt detailliert an.
			</p>
			<p>
				Wie versprochen werden wir auf dieser Reise durch Node.js auch einige fortgeschrittene Konzepte in Sachen JavaScript kennenlernen. Wir erfahren, wie sich diese Konzepte anwenden lassen und warum wir diese und nicht die aus anderen Programmiersprachen bekannten Konzepte anwenden sollten.
			</p>
			<p>
				Der fertige Quelltext der Anwendung findet sich im <a href="https://github.com/ManuelKiessling/NodeBeginnerBook/tree/master/code/application">Github Repository</a>.
			</p>

			<div id="table-of-contents-headline">Inhaltsverzeichnis</div>
			<div id="table-of-contents"></div>

			<h2>JavaScript und Node.js</h2>

			<h3>JavaScript und Du</h3>
			<p>
				Bevor wir über die Technik sprechen, nehmen wir uns einen Moment Zeit und sprechen über Sie und Ihre Beziehung zu Javascript. Dieses Kapitel gibt Ihnen die Möglichkeit, einzuschätzen, ob sich das Lesen dieses Buchs für Sie überhaupt rentiert.
			</p>
			<p>
				Wenn Sie wie ich sind, haben Sie vor sehr langer Zeit bereits  mit HTML "Entwicklung" angefangen. Sie sind irgendwann über dieses komische Ding "JavaScript" gestolpert, aber Sie haben es nie wirklich richtig eingesetzt und nur hier und da ein bisschen Spielerei in Ihre Websites eingebaut.
			</p>
			<p>
				Was Sie wirklich wollten, war das "echte Zeug". Sie haben gelernt, komplexe Website mit richtigen Programmiersprachen wie PHP, Ruby oder Java zu bauen und haben angefangen, "Backend" Code zu schreiben.
			</p>
			<p>
				Trotzdem haben Sie immer ein Auge auf JavaScript geworfen. Sie haben mit der Einführung von jQuery oder Prototype und wie sie nicht alle heißen gesehen, dass JavaScript erwachsener wurde und dass man mit JavaScript wohl mehr machen kann, als nur <em>window.open()</em>.
			</p>
			<p>
				Wie dem auch sei, das war alles nur "Frontend" Zeug und obwohl es nett ist, jQuery zur Seite zu haben, wenn man Websites ein bisschen aufpeppen wollte, waren Sie am Ende doch nur JavaScript <em>Benutzer</em>, aber nicht wirklich ein JavaScript <em>Entwickler</em>.
			</p>
			<p>
				Und dann kam Node.js. Serverbasiertes JavaScript - wie cool ist das denn bitte?
			</p>
			<p>
				Sie haben sich also dazu entschlossen, sich das neue alte doch nochmal unter die Lupe zu nehmen. Aber Moment: Node.js Anwendungen zu schreiben, ist eine Sache; eine andere ist es, zu verstehen, warum sie so geschrieben werden, wie man sie schreibt. Das heißt JavaScript verstehen - und zwar diesmal <em>wirklich</em>.
			</p>
			<p>
				Hier ist das Problem: Weil JavaScript mindestens zwei, meistens aber mehr Gesichter hat (der lustige kleine DHTML-Helfer Mitte der 90er, etwas ernsthafterer Frontend-Kram wie jQuery und dergleichen, und jetzt server-seitig), ist es nicht sehr einfach, Informationen zu finden, die Ihnen helfen, JavaScript auf die "richtige" Art und Weise zu lernen. Gerade in Bezug auf die Entwicklung von Node.js Anwendungen und zwar so, dass Sie nicht das Gefühl haben, JavaScript nur zu benutzen, sondern es wirklich zu entwickeln. 
			</p>
			<p>
				Denn das ist ja der eigentliche Clue: Sie sind bereits ein erfahrer Entwickler, Sie wollen neue Techniken nicht einfach durch stümperhaftes Rumprobieren lernen; Sie wollen sicher sein, dass Sie es von Grund auf richtig lernen.
			</p>
			<p>
				Es gibt natürlich jede Menge hervorragende Dokumentation da draußen, aber Dokumentation alleine ist manchmal eben einfach nicht genug. Was man braucht ist eine führende Hand.
			</p>
			<p>
				Mein Ziel ist, Sie zu führen.
			</p>

			<h3>Eine Warnung vorweg</h3>
			<p>
				Da draußen gibt es eine Menge wirklich hervorragender JavaScript-Menschen. Ich bin keiner davon!
			</p>
			<p>
				Ich bin wirklich nur der Typ, über den ich vorhin gesprochen habe. Ich weiß ein bisschen was über die Backend-Entwicklung von Webanwendungen, aber ich bin ein Anfänger, was "echtes" JavaScript angeht und sowieso komplett unbedarft in Sachen Node.js. Ich habe mir erst vor Kurzem einige fortgeschrittene Kentnisse in JavaScript angeeignet. Ich bin also nicht sehr erfahren.
			</p>
			<p>
				Deswegen handelt es sich hierbei auch nicht um ein "Vom Einsteiger zum Profi" Buch. Es ist eher ein "Vom Anfänger zum fortgeschrittenen Anfänger" Buch.
			</p>
			<p>
				Wenn ich es nicht vergeigt habe, wird das hier die Art von Buch werden, die ich mir gewünscht hätte, als ich mit Node.js angefangen habe.
			</p>

			<h3>Serverseitiges JavaScript</h3>
			<p>
				Die erste Form von JavaScript existierte in den Browsern.Aber das ist nur der Kontext. Es beschreibt ganz gut, was Sie mit der Sprache anfangen können, aber es sagt wenig darüber aus, was die Sprache an sich zu leisten im Stande ist. JavaScript ist eine "vollständige" Sprache: Sie können sie in unterschiedlichen Bereichen anwenden und Sie können damit alles realisieren, was Sie auch mit anderen "vollständigen" Sprache machen können.
			</p>
			<p>
				Node.js macht da keine Ausnahme: Es erlaubt Ihnen, JavaScript im "Backend", also außerhalb des Browsers, auszuführen.
			</p>
			<p>
				Um das JavaScript auszuführen, was Sie im "Backend" schreiben, muss dieses interpretiert und - natürlich - ausgeführt werden.Das genau macht Node.js, indem es die Googles V8 VM benutzt, die gleiche Laufzeit-Umgebung für JavaScript, die Google Chrome verwendet.
			</p>
			<p>
				Zusätzlich kommt Node.js mit jede Menge nützlicher Module, damit Sie das Rad nicht ständig neu erfinden müssen - wie zum Beispiel eine Zeichenfolge auf der Konsole ausgeben.
			</p>
			<p>
				Aus diesem Grund ist Node.js zwei Dinge gleichzeitig: eine Laufzeit-Umgebung und eine Script-Bibliothek.
			</p>
			<p>
				Damit Sie damit auch arbeiten können, müssen Sie Node.js zuerst installieren.Bevor ich hier zum x-ten Mal diesen Vorgang beschreibe, möchte ich lieber auf folgende <a href="https://github.com/joyent/node/wiki/Installation"   title="Building and Installing Node.js">Installationsanweisung</a> verweisen. Wenn Sie fertig sind und alles läuft, kommen Sie einfach wieder her.
			</p>

			<h3>"Hallo Welt"</h3>
			<p>
				Na dann auf ins kalte Wasser. Schreiben wir unsere erste Node.js Anwendung: "Hallo Welt".
			</p>
			<p>
				Öffnen Sie Ihren Lieblingstexteditor und erstellen Sie eine neue Datei namens <em>hallowelt.js</em>. Wir möchten, dass dieses Script "Hallo Welt" auf dem STDOUT ausgibt und hier ist der dafür benötigte Code:
			</p>
<pre class="prettyprint lang-js">console.log("Hallo Welt");
</pre>
			<p>
				Speichern Sie die Datei und führen Sie sie mit Node.js aus:
			</p>
<pre>node hallowelt.js</pre>
			<p>
				Das sollte im Terminal <em>Hallo Welt</em> ausgeben.
			</p>
			<p>
				Okay - das ist langweilig, oder? Schreiben wir mal was Ordentliches.
			</p>


			<h2>Eine richtig dicke Webanwendung mit Node.js</h2>

			<h3>Der Anwendungsfall</h3>
			<p>
				Machen wir's einfach, aber auch realistisch:
			</p>
			<ul><li>	Der Benutzer soll unsere Anwendung mit einem Web-Browser bedienen können.</li><li>	Der Benutzer soll eine Startseite sehen, wenn er folgende URL aufruft: http://<em>domain</em>/start. Dort soll ein Upload-Formular erscheinen.</li><li>	Wenn der Benutzer ein Bild zum Upload auswählt und das Formular abschickt, soll das Bild unter http://<em>domain</em>/upload dargestellt werden, sobald der Upload abgeschlossen ist.</li>
			</ul>
			<p>
				So weit so gut. Das lässt sich nun bekanntlich damit erreichen, dass wir ein bisschen auf Google suchen und am Ende <em>irgendwas</em> zusammenkopieren. Aber genau das wollen wir ja nicht.
			</p>
			<p>
				Außerdem wollen wir nicht nur den unbedingt notwendigen Code schreiben, damit die Anwendung das tut, was wir von ihr erwarten. Egal, ob dieser Code nun besonders schlank, elegant und korrekt ist. Wir wollen absichtlich etwas mehr Abstraktion als nötig einbauen, um ein Gefühl dafür zu kommen, wie man komplexe Node.js Anwendungen konzipiert und programmiert.
			</p>

			<h3>Der Anwenungsaufbau</h3>
			<p>
				Zerlegen wir mal unsere Anwendung. Welche Teilbereiche sind nötig, damit wir am Ende unseren Anwendungsfall voll abdecken?
			</p>
			<ul><li>	Wir wollen Webseiten ausliefern, also benötigen wir einen <strong>HTTP server</strong></li><li>	Unser Server soll auf unterschiedliche Anfragen gezielt reagieren, je nachdem welche URL aufgerufen wurde. Also benötigen wir soetwas wie einen <strong>Router</strong> um Anfragen gezielt beantworten zu können.</li><li>	Um die Anfragen an den Server zu beantworten, die durch den Router ausgewertet wurden, benötigen wir <strong>Request Handler</strong></li><li>	Der Router muss möglicherweise auch Daten verarbeiten, die via POST gesendet werden und diese an den Request Handler weiterreichen. Dazu benötigen wir das <strong>Request Data Handling.</strong></li><li>	Wir möchten aber nicht nur auf Anfragen reagieren, sondern auch Inhalte darstellen, wenn die dazugehörigen URLs aufgerufen werden. Also benötigen wir auch eine irgendwie geartete <strong>View Logik</strong>, welche von den Request Handlern dazu verwendet werden kann, Informationen an den Benutzer zu senden.</li><li>	Zu guter letzt soll der Benutzer Bilder hochladen können, also benötigen wir auch ein <strong>Upload Handling</strong>, welches sich um die Abwicklung kümmert.</li>
			</ul>
			<p>
				Denken wir mal kurz darüber nach, wie wir diese Anforderungen mit PHP umsetzen würden. Es ist sicherlich kein Geheimnis, dass das typische Setup dafür eine Apache HTTP Server mit mod_php5 sein dürfte.<br />Was aber direkt bedeutet, dass der ganze Bereich "Wir müssen Webseiten ausliefern und auf Anfragen reagieren können" nicht mit PHP selbst zu tun hat.
			</p>
			<p>
				Nun, mit Node läuft der Hase etwas anders. Denn bei Node.js bauen wir nicht nur unsere Anwendung, wir implementieren auch den gesamten Server. Genaugenommen sind also unsere Anwendung und der Server ein und dasselbe.
			</p>
			<p>
				Das klingt jetzt vielleicht nach sehr viel Arbeit, aber wir werden gleich sehen, dass es mit Node.js alles andere als schwer ist.
			</p>
			<p>
				Fangen wir also mal ganz vorne an und implementieren den ersten Teil unserer Anwendung: Den HTTP-Server.
			</p>

			<h2>Die Anwendungsteile bauen</h2>
			<h3>Ein einfacher HTTP-Server</h3>
			<p>
				Als ich an den Punkt kam, an dem ich meine erste Node.js Anwendung schreiben wollte, fragte ich mich nicht nur, wie ich sie programmieren sollte, sondern auch, wie ich meinen Code am besten organsiere.<br/>Sollte ich alles in eine Datei packen? Viele Tutorials zum Thema HTTP-Server im Web sagen einem, alles in eine Datei zu packen.Was aber, wenn ich meinen Code übersichtlich halten möchte, auch wenn ich jede Menge Zeug reinpacke?
			</p>
			<p>
				Wie sich herausstellte, ist es sehr einfach, die verschiedenen Bereiche suaber zu trennen, indem man sie in Module verpackt.
			</p>
			<p>
				Das stellt sicher, dass man immer eine saubere Hauptdatei hat, welche mit Node.js ausgeführt wird und saubere Module ebenso, welche nicht nur von der Hauptdatei sondern auch anderen Skripten genutzt werden können.
			</p>
			<p>
				Also legen wir jetzt mal unsere Hauptdatei für unsere Anwendung an und ein Modul, welches unseren HTTP-Server enthält.
			</p>
			<p>
				Mein Erfahrung zeigt, dass es mehr oder weniger Standard ist, die Hauptdatei <em>index.js</em> zu nennen. Den Server verpackt man am sinnigstens in der Datei <em>server.js</em>.
			</p>
			<p>
				Fangen wir mit dem Server-Modul an. Erstellen Sie die Datei <em>server.js</em> im Hauptverzeichnis Ihres Projekts. Schreiben Sie dann in diese Datei folgenden Code:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hallo Welt");
  response.end();
}).listen(8888);
</pre>
			<p>
				Das wars! Sie haben soeben einen funktionstüchtigen Server geschrieben. Testen wir das Ganze! Zuerst führen Sie das Skript mit Node.js aus:
			</p>
<pre>node server.js</pre>
			<p>
				Nun starten Sie Ihren Browser und öffnen Sie <a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>.Jetzt sollte auf Ihrem Bildschirm eine Webseite mit der bekannten "Hallo Welt"-Anzeige erscheinen.
			</p>
			<p>
				Das ist doch toll, oder nicht? Schauen wir uns doch mal im Detail an, was hier genau abläuft und heben wir uns die Frage nach der Organisation des Codes für später auf. Ich verspreche, wir kommen nochmal drauf zurück!
			</p>

			<h3>Analyse unseres HTTP Servers</h3>
			<p>
				Dann schauen wir uns mal an, was hier vor sich geht.
			</p>
			<p>
				Die erste Zeile lädt <em>(require)</em> das <em>http</em> Modul, welches mit Node.js mitgeliefert wird und stellt es in der Variable <em>http</em> zur Verfügung.
			</p>
			<p>
				Anschließend rufen wir eine im http-Modul vorhandene Funktion auf: <em>createServer</em>. Diese Funktion gibt als Ergebnis ein Objekt zurück. Diese Objekt besitzt die Methode <em>listen</em>, und nimmt als Argument einen numerischen Wert an, der die Port-Nummer unseres Servers festlegt, auf der er "zuhören" wird.
			</p>
			<p>
				Bitte ignorieren Sie mal für einen Moment die Funktion, die nach der öffnenden Klammer von <em>http.createServer</em> folgt.
			</p>
			<p>
				Wir hätten den Code auch folgendermaßen schreiben können, um den Server zu starten und auf Port 8888 zuhören zu lassen:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

var server = http.createServer();
server.listen(8888);</pre>
			<p>
				Das startet unseres HTTP Server auf Port 8888, macht sonst aber gar nichts (nicht mal auf ankommende Anfragen antworten).
			</p>
			<p>
				Das wirklich Interessante aber (und, wenn Sie sich mit einer etwas konservativeres Sprache wie PHP auskennen, vielleicht auch ungewöhnliche) ist, dass wir eine Funktion genau da definieren, wo Sie eigentlich einen Parameter des <em>createServer()</em> Aufrufs erwarten würden.
			</p>
			<p>
				Es zeigt sich also, dass genau diese Funktion wirklich der einzige Parameter IST, den wir dem <em>createServer()</em> Aufruf übergeben. Denn in JavaScript können wir Funktionen genauso übergeben, wie jeden anderen Wert.
			</p>

			<h3>Funktionen als Parameter übergeben</h3>
			<p>
				Sie können beispielsweise so etwas wie das hier machen:
			</p>
<pre class="prettyprint lang-js">function sprich(wort) {
  console.log(wort);
}

function ausfuehren(eineFunktion, wert) {
  eineFunktion(wert);
}

ausfuehren(sprich, "Hallo Welt");</pre>
			<p>
				Bitte mal aufmerksam lesen! Was wir hier tun ist Folgendes: Wir übergeben <strong>die Funktion</strong> <em>sprich</em> als ersten Parameter an die Funktion <em>ausfuehren</em>. Wir übergeben <strong>nicht</strong> den Rückgabewert dieser Funktion, sonder die Funktion <em>sprich</em> selbst!
			</p>
			<p>
				Somit wird die Funktion <em>sprich</em> die lokale Variable <em>eineFunktion</em> innerhalb der Funktion <em>ausfuehren</em>. Nun kann <em>ausfuehren</em> diese Funktion über diese Variable direkt aufrufen <em>eineFunktion()</em> (einfach durch Hinzufügen der Klammern).
			</p>
			<p>
				Natürlich kann <em>ausfuehren</em> die für <em>sprich</em> notwendigen Parameter ebenfalls an <em>eineFunktion()</em> übergeben.
			</p>
			<p>
				Wir können also, genau wie wir es gerade getan haben, Funktionen an andere Funktionen über ihren Namen als Parameter übergeben. Aber wir müssen diese Funktionen gar nicht unbedingt vorher schon definieren - wir können während des Aufrufs selbst Funktionen definieren und an andere Funktionen übergeben:
			</p>
<pre class="prettyprint lang-js">function ausfuerhen(eineFunktion, wert) {
  eineFunktion(wert);
}

ausfuehren(function(wort){ console.log(wort) }, "Hallo Welt");
</pre>
			<p>
				We define the function we want to pass to <em>execute</em>right there at the place where <em>execute</em> expects itsfirst parameter.
			</p>
			<p>
				This way, we don't even need to give the function a name,which is why this is called an <em>anonymous function</em>.
			</p>
			<p>
				This is a first glimpse at what I like to call "advanced"JavaScript, but let's take it step by step. For now, let'sjust accept that in JavaScript, we can pass a function asa parameter when calling another function. We can do thisby assigning our function to a variable, which we thenpass, or by defining the function to pass in-place.
			</p>

			<h3>How function passing makes our HTTP server work</h3>
			<p>
				With this knowledge, let's get back to our minimalisticHTTP server:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello World");
  response.end();
}).listen(8888);
</pre>
			<p>
				By now it should be clear what we are actually doing here:we pass the <em>createServer</em> function an anonymousfunction.
			</p>
			<p>
				We could achieve the same by refactoring our code to:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

function onRequest(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello World");
  response.end();
}

http.createServer(onRequest).listen(8888);
</pre>
			<p>
				Maybe now is a good moment to ask: Why are we doing itthat way?
			</p>

			<h3>Event-driven callbacks</h3>
			<p>
				The answer is a) not that easy to give (at least for me), andb) lies in the very nature of how Node.js works. It'sevent-driven, which is the reason why it's so fast.
			</p>
			<p>
				You might want to take the time to read FelixGeisend&ouml;rfer's excellent post<a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb">Understanding node.js</a>for some background explanation.
			</p>
			<p>
				It all boils down to the fact that Node.js works event-driven.Oh and yes, I, too, don't know exactly what that means.But I will try and explain, why this makes sense for uswho want to write web based applications in Node.js.
			</p>
			<p>
				When we call the <em>http.createServer</em> method, weof course not only want to have a server listening atsome port, we also want to do something when there is anHTTP request to this server.
			</p>
			<p>
				The problem is, this happens asynchronously: it happensat any given time, but we only have a single process inwhich our server runs.
			</p>
			<p>
				When writing PHP applications, we aren't bothered by thisat all: whenever there is an incoming HTTP request, thewebserver (usually Apache) forks a new process for justthis request, and starts the according PHP script fromscratch, which is then executed from top to bottom.
			</p>
			<p>
				So in regards of control flow, we are in the midst of ourNode.js program when a new request arrives at port 8888 - howto handle this without going insane?
			</p>
			<p>
				Well, this is where the event-driven design ofNode.js/JavaScript actually helps, although we need to learnsome new concepts in order to master it. Let's see howthese concepts are applied in our server code.
			</p>
			<p>
				We create the server, and pass a function to the methodcreating it. Whenever our server receives a request, thefunction we passed will be called.
			</p>
			<p>
				We don't know when this is going to happen, but we now havea place where we can handle an incoming request. It's ourpassed function, no matter if we first defined it or passedit anonymously.
			</p>
			<p>
				This concept is called a <em>callback</em>. We pass intosome method a function, and the method uses this functionto <em>call back</em> if an event related to the methodoccurs.
			</p>
			<p>
				At least for me, this took some time to understand. Justread Felix' blog post again if you are still unsure.
			</p>
			<p>
				Let's play around a bit with this new concept. Can we provethat our code continues after creating the server, even ifno HTTP request happened and the callback function wepassed isn't called? Let's try it:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

function onRequest(request, response) {
  console.log("Request received.");
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello World");
  response.end();
}

http.createServer(onRequest).listen(8888);

console.log("Server has started.");
</pre>
			<p>
				Note that I use <em>console.log</em> to	output a text wheneverthe <em>onRequest</em> function (our callback) is triggered,and	another text right <em>after</em> starting the HTTP server.
			</p>
			<p>
				When we start this (<em>node server.js</em>, as always), itwill immediately output "Server has started." on thecommand line. Whenever we request our server (by opening<a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>in our browser), the message "Request received." is printedon the command line.
			</p>
			<p>
				Event-driven asynchronous server-side JavaScript withcallbacks in action :-)
			</p>
			<p>
				(Note that our server will probably write "Request received."to STDOUT two times upon opening the page in a browser. That'sbecause most browser will try to load the favicon by requestinghttp://localhost:8888/favicon.ico whenever you openhttp://localhost:8888/).
			</p>

			<h3>How our server handles requests</h3>
			<p>
				Ok, let's quickly analyze the rest of our server code, thatis, the body of our callback function <em>onRequest()</em>.
			</p>
			<p>
				When the callback fires and our <em>onRequest()</em> functiongets triggered, two parameters are passed into it:<em>request</em> and <em>response</em>.
			</p>
			<p>
				Those are objects, and you can use their methods to handlethe	details of the HTTP request that occured and to respondto the request (i.e., to actually send something overthe wire back to the browser that requested your server).
			</p>
			<p>
				And our code does just that: Whenever a request isreceived, it uses the <em>response.writeHead()</em>function to send an HTTP status 200 and content-type in theHTTP response header, and the <em>response.write()</em>function to send the text "Hello World" in the HTTPresponse body.
			</p>
			<p>
				At last, we call <em>response.end()</em> to actually finishour response.
			</p>
			<p>
				At this point, we don't care for the details of therequest, which is why we don't use the <em>request</em>object at all.
			</p>


			<h3>Finding a place for our server module</h3>
			<p>
				Ok, I promised we will get back to how to organize ourapplication. We have the code for a very basic HTTP server inthe file <em>server.js</em>, and I mentioned that it's commonto have a main file called <em>index.js</em> which is usedto bootstrap and start our application by making use of theother modules of the application (like the HTTP server modulethat lives in <em>server.js</em>).
			</p>
			<p>
				Let's talk about how to make server.js a real Node.js modulethat can be used by our yet-to-be-written <em>index.js</em>main file.
			</p>
			<p>
				As you may have noticed, we already used modules in our code,like this:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

...

http.createServer(...);
</pre>
			<p>
				Somewhere within Node.js lives a module called "http", and we canmake use of it in our own code by requiring it and assigningthe result of the require to a local variable.
			</p>
			<p>
				This makes our local variable an object that carries all thepublic methods the <em>http</em> module provides.
			</p>
			<p>
				It's common practice to choose the name of the module for thename of the local variable, but we are free to choose whateverwe like:
			</p>
<pre class="prettyprint lang-js">var foo = require("http");

...

foo.createServer(...);
</pre>
			<p>
				Fine, it's clear how to make use of internal Node.js modules. Howdo we create our own modules, and how do we use them?
			</p>
			<p>
				Let's find out by turning our <em>server.js</em> script into areal module.
			</p>
			<p>
				Turns out, we don't have to change that much. Making some codea module means we need to <em>export</em> those parts of itsfunctionality that we want to provide to scripts that requireour module.
			</p>
			<p>
				For now, the functionality our HTTP server needs to export issimple: scripts requiring our server module simply need tostart the server.
			</p>
			<p>
				To make this possible, we will put our server code into afunction named <em>start</em>, and we will export thisfunction:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

function start() {
  function onRequest(request, response) {
    console.log("Request received.");
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				This way, we can now create our main file <em>index.js</em>,and start our HTTP there, although the code for the server isstill in our <em>server.js</em> file.
			</p>
			<p>
				Create a file <em>index.js</em> with the following content:
			</p>
<pre class="prettyprint lang-js">var server = require("./server");

server.start();
</pre>
			<p>
				As you can see, we can use our server module just like anyinternal module: by requiring its file and assigning it toa variable, its exported functions become available to us.
			</p>
			<p>
				That's it. We can now start our app via our main script, and itstill does exactly the same:
			</p>
<pre>node index.js</pre>
			<p>
				Great, we now can put the different parts of our applicationinto different files and wire them together by making themmodules.
			</p>
			<p>
				We still have only the very first part of our application inplace: we can receive HTTP requests. But we need to dosomething with them - depending on which URL the browserrequested from our server, we need to react differently.
			</p>
			<p>
				For a very simple application, you could do this directlywithin the callback function <em>onRequest()</em>. But as I said,let's add a bit more abstraction in order to make our exampleapplication a bit more interesting.
			</p>
			<p>
				Making different HTTP requests point at different parts of ourcode is called "routing" - well, then, let's create a modulecalled <em>router</em>.
			</p>

			<h3>What's needed to "route" requests?</h3>
			<p>
				We need to be able to feed the requested URL and possibleadditional GET and POST parameters into our router, and basedon these the router then needs to be able to decide which codeto execute (this "code to execute" is the third part of ourapplication: a collection of request handlers that do theactual work when a request is received).
			</p>
			<p>
				So, we need to look into the HTTP requests and extract therequested URL as well as the GET/POST parameters from them.It could be argued if that should be part of the router orpart of the server (or even a module of its own), but let'sjust agree on making it part of our HTTP server for now.
			</p>
			<p>
				All the information we need is available through the<em>request</em> object which is passed as the first parameterto our callback function <em>onRequest()</em>. But to interpretthis information, we need some additional Node.js modules, namely<em>url</em> and <em>querystring</em>.
			</p>
			<p>
				The <em>url</em> module provides methods which allow us toextract the different parts of a URL (like e.g. the requestedpath and query string), and <em>querystring</em> can in turn beused to parse the query string for request parameters:
			</p>
<pre>                               url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&amp;hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring(string)["foo"]    |
                                            |
                         querystring(string)["hello"]
</pre>
			<p>
				We can, of course, also use <em>querystring</em> to parse thebody of a POST request for parameters, as we will seelater.
			</p>
			<p>
				Let's now add to our <em>onRequest()</em> function the logicneeded to find out which URL path the browser requested:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start() {
  function onRequest(request, response) {
	var pathname = url.parse(request.url).pathname;
	console.log("Request for " + pathname + " received.");
	response.writeHead(200, {"Content-Type": "text/plain"});
	response.write("Hello World");
	response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				Fine. Our application can now distinguish requests based on theURL path requested - this allows us to map requests to ourrequest handlers based on the URL path using our (yet to bewritten) router.
			</p>
			<p>
				In the context of our application, it simply means that we willbe able to have requests for the <em>/start</em> and<em>/upload</em> URLs handled by different parts of ourcode. We will see how everything fits together soon.
			</p>
			<p>
				Ok, it's time to actually write our router. Create a new filecalled <em>router.js</em>, with the following content:
			</p>
<pre class="prettyprint lang-js">function route(pathname) {
  console.log("About to route a request for " + pathname);
}

exports.route = route;
</pre>
			<p>
				Of course, this code basically does nothing, but that's ok fornow. Let's first see how to wire together this router with ourserver before putting more logic into the router.
			</p>
			<p>
				Our HTTP server needs to know about and make use of our router.We could hard-wire this dependency into the server, but becausewe learned the hard way from our experience with otherprogramming languages, we are going to loosely couple serverand router by injecting this dependency (you may want to read<a href="http://martinfowler.com/articles/injection.html">Martin Fowlers excellent post on Dependency Injection</a>for	background information).
			</p>
			<p>
				Let's first extend our server's <em>start()</em> function inorder to enable us to pass the route function to be used byparameter:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    route(pathname);

    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				And let's extend our <em>index.js</em> accordingly, that is,injecting the route function of our router into the server:
			</p>
<pre class="prettyprint lang-js">var server = require("./server");
var router = require("./router");

server.start(router.route);

</pre>
			<p>
				Again, we are passing a function, which by now isn't any newsfor us.
			</p>
			<p>
				If we start our application now (<em>node index.js,as always</em>), and request an URL, you can now see from theapplication's output that our HTTP server makes use of ourrouter and passes it the requested pathname:
			</p>
<pre>bash$ node index.js
Request for /foo received.
About to route a request for /foo
</pre>
			<p>
				(I omitted the rather annoying output for the /favicon.icorequest).
			</p>

			<h3>Execution in the kingdom of verbs</h3>
			<p>
				May I once again stray away for a while and talk aboutfunctional programming again?
			</p>
			<p>
				Passing functions is not only a technical consideration.With regard to software design, it's almost philosophical.Just think about it: in our index file, we could have passedthe	<em>router</em> object into the server, and the servercould have called this object's <em>route</em> function.
			</p>
			<p>
				This way, we would have passed a <em>thing</em>, and the serverwould have used this thing to <em>do</em> something. Hey,router thing, could you please route this for me?
			</p>
			<p>
				But the server doesn't need the thing. It only needs to getsomething <em>done</em>, and to get something done, you don'tneed things at all, you need <em>actions</em>. You don't need<em>nouns</em>, you need <em>verbs</em>.
			</p>
			<p>
				Understanding the fundamental mind-shift that's at the core ofthis idea is what made me really understand functionalprogramming.
			</p>
			<p>
				And I did understand it when reading Steve Yegge's masterpiece<a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Execution in the Kingdom of Nouns</a>.Go read it now, really. It's one of the best writings relatedto software I ever had the pleasure to encounter.
			</p>

			<h3>Routing to real request handlers</h3>
			<p>
				Back to business. Our HTTP server and our request router arenow best friends and talk to each other as we intended.
			</p>
			<p>
				Of course, that's not enough. "Routing" means, we want tohandle requests to different URLs differently. We would like tohave the "business logic" for requests to <em>/start</em>handled in another function than requests to <em>/upload</em>.
			</p>
			<p>
				Right now, the routing "ends" in the router, and the router isnot the place to actually "do" something with the requests,because that wouldn't scale well once our application becomesmore complex.
			</p>
			<p>
				Let's call these functions, where requests are routed to,<em>request handlers</em>. And let's tackle those next, becauseunless we have these in place there isn't much sense in doinganything with the router for now.
			</p>
			<p>
				New application part, new module - no surprise here. Let'screate a module called requestHandlers, add a placeholderfunction for every request handler, and export these asmethods of the module:
			</p>
<pre class="prettyprint lang-js">function start() {
  console.log("Request handler 'start' was called.");
}

function upload() {
  console.log("Request handler 'upload' was called.");
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				This allows us to wire the request handlers into the router,giving our router something to route to.
			</p>
			<p>
				At this point we need to make a decision: do we hard-code usageof the requestHandlers module into the router, or do we want abit more dependency injection? Although dependency injection,like every other pattern, shouldn't be used only for the sakeof using it, in this case it makes sense to loosely couple therouter and its request handlers, and thus making the routerreally reusable.
			</p>
			<p>
				This means we need to pass the request handlers from our serverinto our router, but this feels even more wrong, which is whywe should go the whole way and pass them to the server from	ourmain file, and passing it on to the router from there.
			</p>
			<p>
				How are we going to pass them? Right now we have two handlers,but in a real application, this number is going to increase andvary, and we sure don't want to fiddle around mapping requeststo handlers in the router anytime a new URL / request handleris added. And having some<em>if request == x then call handler y</em> in the routerwould be more than ugly.
			</p>
			<p>
				A varying number of items, each mapped to a string (therequested URL)? Well, sounds like an associative array would bea perfect fit.
			</p>
			<p>
				Well, this finding is slightly disappointed by the fact thatJavaScript doesn't provide associative array - or does it?Turns out, it's actually objects that we want to use if we needan associative array!
			</p>
			<p>
				There's a nice introduction to this at<a href="http://msdn.microsoft.com/en-us/magazine/cc163419.aspx">http://msdn.microsoft.com/en-us/magazine/cc163419.aspx</a>,let me quote the relevant part:
			</p>
			<blockquote><p>
					In C++ or C#, when we’re talking about objects, we're	referring to instances of classes or structs. Objects have	different properties and methods, depending on which	templates (that is, classes) they are instantiated from.	That's not the case with JavaScript objects. In JavaScript,	objects are just collections of name/value pairs - think of a	JavaScript object as a dictionary with string keys.</p>
			</blockquote>
			<p>
				If JavaScript objects are just collections of name/value pairs,how can they have methods? Well, the values can be strings,numbers etc. - or functions!
			</p>
			<p>
				Ok, now finally back to the code. We decided we want to passthe list of requestHandlers as an object, and in order toachieve loose coupling we want to inject this object into the<em>route()</em>.
			</p>
			<p>
				Let's start with putting the object together in our main file<em>index.js</em>:
			</p>
<pre class="prettyprint lang-js">var server = require("./server");
var router = require("./router");
var requestHandlers = require("./requestHandlers");

var handle = {}
handle["/"] = requestHandlers.start;
handle["/start"] = requestHandlers.start;
handle["/upload"] = requestHandlers.upload;

server.start(router.route, handle);
</pre>
			<p>
				Although <em>handle</em> is more of a "thing" (a collection ofrequest handlers), I propose we name it like a verb, becausethis will result in a fluent expression in our router, as wewill see soon.
			</p>
			<p>
				As you can see, it's really simple to map different URLs to thesame request handler: by adding a key/value pair of<em>"/"</em> and <em>requestHandlers.start</em>, we can expressin a nice and clean way that not only requests to<em>/start</em>, but also requests to <em>/</em> shall behandled by the <em>start</em> handler.
			</p>
			<p>
				After defining our object, we pass it into the server as anadditional parameter. Let's change our <em>server.js</em> tomake use of	it:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    route(handle, pathname);

    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				We've added the <em>handle</em> parameter to our<em>start()</em> function, and pass the handle object on tothe <em>route()</em> callback, as its first parameter.
			</p>
			<p>
				Let's change the <em>route()</em> function accordingly, in our<em>router.js</em> file:
			</p>
<pre class="prettyprint lang-js">function route(handle, pathname) {
  console.log("About to route a request for " + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname]();
  } else {
    console.log("No request handler found for " + pathname);
  }
}

exports.route = route;
</pre>
			<p>
				What we do here is, we check if a request handler for the givenpathname exists, and if it does, we simply call the accordingfunction. Because we can access our request handler functionsfrom our object just as we would access an element of anassociative array, we have this nice fluent<em>handle[pathname]();</em> expression I talked about earlier:"Please, <em>handle</em> this <em>pathname</em>".
			</p>
			<p>
				Ok, that's all we need to wire server, router, and requesthandlers together! When starting our application and requesting<a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>in our browser, we can prove that the correct request handlerwas indeed called:
			</p>
<pre>Server has started.
Request for /start received.
About to route a request for /start
Request handler 'start' was called.
</pre>
			<p>
				And opening <a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>in our browser proves that these requests, too, are indeed handled bythe <em>start</em> request handler:
			</p>
<pre>Request for / received.
About to route a request for /
Request handler 'start' was called.
</pre>


			<h3>Making the request handlers respond</h3>
			<p>
				Beautiful. Now if only the request handlers could actually sendsomething back to the browser, that would be even better,right?
			</p>
			<p>
				Remember, the "Hello World" your browser displays uponrequesting a page still comes from the <em>onRequest</em>function in our <em>server.js</em> file.
			</p>
			<p>
				"Handling request" means "answering requests" after all, thuswe need to enable our request handlers to speak with thebrowser just like our <em>onRequest</em> function does.
			</p>

			<h4>How to not do it</h4>
			<p>
				The straight-forward approach we -  as developers with abackground in PHP or Ruby - might want to follow is actuallyvery deceitful: it works like a charm, seems to make a lot ofsense, and then suddenly screws things up when we don't expectit.
			</p>
			<p>
				What I mean by "straight-forward approach" is this: make therequest handlers <em>return()</em> the content they want todisplay to the user, and send this response data in the<em>onRequest</em> function back to the user.
			</p>
			<p>
				Let's just do this, and then see why it's not such an overlygood idea.
			</p>
			<p>
				We start with the request handlers and make them return what wewould like to display in the browser. We need to change<em>requestHandlers.js</em> to this:
			</p>
<pre class="prettyprint lang-js">function start() {
  console.log("Request handler 'start' was called.");
  return "Hello Start";
}

function upload() {
  console.log("Request handler 'upload' was called.");
  return "Hello Upload";
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				Good. Likewise, the router needs to return to the server whatthe request handlers return to him. We therefore need to edit<em>router.js</em> like this:
			</p>
<pre class="prettyprint lang-js">function route(handle, pathname) {
  console.log("About to route a request for " + pathname);
  if (typeof handle[pathname] === 'function') {
    return handle[pathname]();
  } else {
    console.log("No request handler found for " + pathname);
    return "404 Not found";
  }
}

exports.route = route;
</pre>
			<p>
				As you can see, we also return some text if the request couldnot be routed.
			</p>
			<p>
				And last but not least, we need to refactor our server to makeit respond to the browser with the content the request handlersreturned via the router, transforming <em>server.js</em> into:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    response.writeHead(200, {"Content-Type": "text/plain"});
    var content = route(handle, pathname)
    response.write(content);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				If we start our rewritten application, everything works likea charm: requesting <a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>results in "Hello Start" being displayed in the browser,requesting <a href="http://localhost:8888/upload" rel="nofollow">http://localhost:8888/upload</a>gives us "Hello Upload", and <a href="http://localhost:8888/foo" rel="nofollow">http://localhost:8888/foo</a>produces "404 Not found".
			</p>
			<p>
				Ok, then why is that a problem? The short answer: because wewill run into problems if one of the request handlers wants to makeuse of a non-blocking operation in the future.
			</p>
			<p>
				Let's take a bit more time for the long answer.
			</p>

			<h4>Blocking and non-blocking</h4>
			<p>
				As said, the problems will arise when we include non-blockingoperations in the request handlers. But let's talk aboutblocking operations first, then about non-blocking operations.
			</p>
			<p>
				And instead of trying to explain what "blocking" and"non-blocking" means, let's demonstrate ourselves what happensif we add a	blocking operation to our request handlers.
			</p>
			<p>
				To do this, we will modify our <em>start</em> request handlerto make it wait 10 seconds before returning its "Hello Start"string. Because there is no such thing as <em>sleep()</em> inJavaScript, we will use a clever hack for that.
			</p>
			<p>
				Please modify <em>requestHandlers.js</em> as follows:
			</p>
<pre class="prettyprint lang-js">function start() {
  console.log("Request handler 'start' was called.");

  function sleep(milliSeconds) {
    var startTime = new Date().getTime();
    while (new Date().getTime() &lt; startTime + milliSeconds);
  }

  sleep(10000);
  return "Hello Start";
}

function upload() {
  console.log("Request handler 'upload' was called.");
  return "Hello Upload";
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				Just to make clear what that does: when the function<em>start()</em> is called, Node.js waits 10 seconds and only thenreturns "Hello Start". When calling <em>upload()</em>, itreturns immediately, just like before.
			</p>
			<p>
				(Of course, you should imagine that instead of sleeping for10 seconds, there would be a real life blocking operation in<em>start()</em>, like some sort of long-running computation.)
			</p>
			<p>
				Let's see what this change does.
			</p>
			<p>
				As always, we need to restart our server. This time, I ask youto follow a slightly complex "protocol" in order to see whathappens: First, open two browser windows or tabs. In the firstbrowser window, please enter <a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>into the address bar, but do not yet open this url!
			</p>
			<p>
				In the second browser window's address bar, enter <a href="http://localhost:8888/upload" rel="nofollow">http://localhost:8888/upload</a>,and again, please do not yet hit enter.
			</p>
			<p>
				Now, do as follows: hit enter on the first window ("/start"),then quickly change to the second window ("/upload") and hitenter, too.
			</p>
			<p>
				What you will notice is this: The /start URL takes 10 secondsto load, as we would expect. But the /upload URL <em>also</em>takes 10 seconds to load, although there is no <em>sleep()</em>in the according request handler!
			</p>
			<p>
				Why? Because <em>start()</em> contains a blocking operation.Like in "it's blocking everything else from working".
			</p>
			<p>
				And that is a problem, because, as the saying goes: <em>"Innode, everything runs in parallel, except your code"</em>.
			</p>
			<p>
				What that means is that Node.js can handle a lot of concurrentstuff, but doesn't do this by splitting everything intothreads - in fact, Node.js is single-threaded. Instead, it doesso by running an event loop, and we the developers can make useof this - we should avoid blocking operations wheneverpossible, and use non-blocking operations instead.
			</p>
			<p>
				But to do so, we need to make use of callbacks by passingfunctions around to other functions that might do somethingthat takes some time (like, e.g. sleep for 10 seconds, or querya database, or do some expensive calculation).
			</p>
			<p>
				This way we are saying <em>"Hey, probablyExpensiveFunction(),please do your stuff, but I, the single Node.js thread, am notgoing to wait right here until you are finished, I willcontinue to execute the lines of code below you, so would youplease take this callbackFunction() here and call it whenyou are finished doing your expensive stuff? Thanks!"</em>
			</p>
			<p>
				(If you would like to read about that in more detail, please havea look at Mixu's post on <a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/">Understanding the node.js event loop</a>.)
			</p>
			<p>
				And we will now see why the way we constructed the "requesthandler response handling" in our application doesn't allow usto make proper use of non-blocking operations.
			</p>
			<p>
				Once again, let's try to experience the problem first-hand bymodifying our application.
			</p>
			<p>
				We are going to use our <em>start</em> request handler for thisagain. Please modify it to reflect the following (file<em>requestHandlers.js</em>):
			</p>
<pre class="prettyprint lang-js">var exec = require("child_process").exec;

function start() {
  console.log("Request handler 'start' was called.");
  var content = "empty";

  exec("ls -lah", function (error, stdout, stderr) {
    content = stdout;
  });

  return content;
}

function upload() {
  console.log("Request handler 'upload' was called.");
  return "Hello Upload";
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				As you can see, we just introduced a new Node.js module,<em>child_process</em>. We did so because it allows us to makeuse of a very simple yet useful non-blocking operation:<em>exec()</em>.
			</p>
			<p>
				What <em>exec()</em> does is, it executes a shell command fromwithin Node.js. In this example, we are going to use it to geta list of all files in the current directory ("ls -lah"),allowing us to display this list in the browser of a userrequesting the <em>/start</em> URL.
			</p>
			<p>
				What the code does is straightforward: create a new variable<em>content</em> (with an initial value of "empty"), execute"ls -lah", fill the	variable with the result, and return it.
			</p>
			<p>
				As always, we will start our application, and visit<a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>.
			</p>
			<p>
				Which loads a beautiful web page that displays the string"empty". What's going wrong here?
			</p>
			<p>
				Well, as you may have already guessed, <em>exec()</em> does itsmagic in a non-blocking fashion. That's a good thing, becausethis way we can execute very expensive shell operations (like,e.g., copying huge files around or similar stuff) withoutforcing our application into a full stop as the blocking<em>sleep</em> operation did.
			</p>
			<p>
				(If you would like to prove this, replace "ls -lah" with amore expensive operation like "find /").
			</p>
			<p>
				But we aren't exactly happy with our elegant non-blockingoperation, when our browser doesn't display its result, right?
			</p>
			<p>
				Well, then, let's fix it. And while we are at it, let's try tounderstand why the current architecture doesn't work.
			</p>
			<p>
				The problem is that <em>exec()</em>, in order to worknon-blocking, makes use of a callback function.
			</p>
			<p>
				In our example, it's an anonymous function which is passed asthe second parameter to the <em>exec()</em> function call:
			</p>
<pre class="prettyprint lang-js">function (error, stdout, stderr) {
  content = stdout;
}
</pre>
			<p>
				And herein lies the root of our problem: our own code isexecuted synchronous, which means that immediately aftercalling <em>exec()</em>, Node.js continues to execute<em>return content;</em>. At this point, <em>content</em> isstill "empty", due to the fact that the callback functionpassed to <em>exec()</em> has not yet been called - because<em>exec()</em> operates asynchronous.
			</p>
			<p>
				Now, "ls -lah" is a very inexpensive and fast operation (unlessthere are millions of files in the directory). Which is why thecallback is called relatively expeditious - but it neverthelesshappens asynchronously.
			</p>
			<p>
				Thinking about a more expensive command	makes this moreobvious: "find /" takes about 1 minute on mymachine, but if I replace "ls -lah" with "find /" in therequest handler, I still immediately receive an HTTP responsewhen opening the /start URL - it's clear that <em>exec()</em>does something in the background, while Node.js itselfcontinues with the application, and we may assume that thecallback function we passed into <em>exec()</em> will be calledonly when the "find /" command has finished running.
			</p>
			<p>
				But how can we achieve our goal, i.e. showing the user a listof files in the current directory?
			</p>
			<p>
				Well, after learning how to <em>not</em> do it, let's discusshow to make our request handlers respond to browser requeststhe right way.
			</p>

			<h4>Responding request handlers with non-blocking operations</h4>
			<p>
				I've just used the phrase "the right way". Dangerous stuff.Quite often, there is no single "right way".
			</p>
			<p>
				But one possible solution for this is, as often with Node.js,to pass functions around. Let's examine this.
			</p>
			<p>
				Right now, our application is able to transport the content(which the request handlers would like to display to the user)from the request handlers to the HTTP server by returning itup through the layers of the application (request handler -&gt;router -&gt; server).
			</p>
			<p>
				Our new approach is as follows: instead of bringing the contentto the server, we will bring the server to the content. To bemore precise, we will inject the <em>response</em> object (fromour server's callback function <em>onRequest()</em>) throughthe router into the request handlers. The handlers will then beable to use this object's functions to respond to requeststhemselves.
			</p>
			<p>
				Enough explanation, here is the step by step recipe on how tochange our application.
			</p>
			<p>
				Let's start with our <em>server.js</em>:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    route(handle, pathname, response);
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				Instead of expecting a return value from the <em>route()</em>function, we pass it a third parameter, our <em>response</em>object. Furthermore, we removed any <em>response</em> methodcalls from the <em>onRequest()</em> handler, because we nowexpect <em>route</em> to take care of that.
			</p>
			<p>
				Next comes <em>router.js</em>:
			</p>
<pre class="prettyprint lang-js">function route(handle, pathname, response) {
  console.log("About to route a request for " + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname](response);
  } else {
    console.log("No request handler found for " + pathname);
    response.writeHead(404, {"Content-Type": "text/plain"});
    response.write("404 Not found");
    response.end();
  }
}

exports.route = route;
</pre>
			<p>
				Same pattern: instead of expecting a return value from ourrequest handlers, we pass the <em>respond</em> object on.
			</p>
			<p>
				If no request handler can be used, we now take care ofresponding with a proper "404" header and body ourselves.
			</p>
			<p>
				And last but not least, we modify <em>requestHandlers.js</em>:
			</p>
<pre class="prettyprint lang-js">var exec = require("child_process").exec;

function start(response) {
  console.log("Request handler 'start' was called.");

  exec("ls -lah", function (error, stdout, stderr) {
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write(stdout);
    response.end();
  });
}

function upload(response) {
  console.log("Request handler 'upload' was called.");
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello Upload");
  response.end();
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				Our handler functions need to accept the response parameter,and have to make use of them in order to respond to therequest directly.
			</p>
			<p>
				The <em>start</em> handler will respond from within theanonymous <em>exec()</em> callback, and the <em>upload</em>handler still simply replies with "Hello Upload", but nowby making use of the <em>response</em> object.
			</p>
			<p>
				If we start our application again (<em>node index.js</em>),this should work as expected.
			</p>
			<p>
				If you would like to prove that an expensive operation behind<em>/start</em> will no longer block requests for<em>/upload</em> from answering immediately, then modify your<em>requestHandlers.js</em> as follows:
			</p>
<pre class="prettyprint lang-js">var exec = require("child_process").exec;

function start(response) {
  console.log("Request handler 'start' was called.");

  exec("find /",
    { timeout: 10000, maxBuffer: 20000*1024 },
    function (error, stdout, stderr) {
      response.writeHead(200, {"Content-Type": "text/plain"});
      response.write(stdout);
      response.end();
    });
}

function upload(response) {
  console.log("Request handler 'upload' was called.");
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello Upload");
  response.end();
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				This will make HTTP requests to <a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>take at least 10 seconds, but requests to <a href="http://localhost:8888/upload" rel="nofollow">http://localhost:8888/upload</a>will be answered immediately, even if /start is stillcomputing.
			</p>


			<h3>Serving something useful</h3>
			<p>
				Until now, what we have done is all fine and dandy, but wehaven't created any value for the customers of ouraward-winning website.
			</p>
			<p>
				Our server, router, and request handlers are in place, thus nowwe can begin to add content to our site which allows our usersto interact and walk through the use case of choosing a file,uploading this file, and viewing the uploaded file in thebrowser. For the sake of simplicity we will assume that onlyimage files are going to be uploaded and displayed through theapplication.
			</p>
			<p>
				Ok, let's take it step by step, but with most of the techniquesand principles of JavaScript explained by now, let's at thesame time accelerate a bit. This author likes to hear himselftalking way too much anyways.
			</p>
			<p>
				Here, step by step means roughly two steps: We will first lookat how to handle incoming POST requests (but not file uploads),and in a second step, we will make use of an external Node.jsmodule for the file upload handling. I've chosen this approachfor two reasons.
			</p>
			<p>
				First, handling basic POST requests isrelatively simple with Node.js, but still teaches us enough tobe worth exercising it.<br/>Second, handling file uploads (i.e.,multipart POST requests) is <em>not</em> simple with Node.js,and therefore is beyond the scope of this tutorial, but usingan external module is itself a lesson that makes sense to beincluded in a beginner's tutorial.
			</p>

			<h4>Handling POST requests</h4>
			<p>
				Let's keep this banally simple: We will present a textarea thatcan be filled by the user and submitted to the server in a POSTrequest. Upon receiving and handling this request, we willdisplay the content of the textarea.
			</p>The HTML for this textarea form needs to be served by our<em>/start</em> request handler, so let's add it right away, infile <em>requestHandlers.js</em>:
			</p>
<pre class="prettyprint lang-js">function start(response) {
  console.log("Request handler 'start' was called.");

  var body = '&lt;html&gt;'+
    '&lt;head&gt;'+
    '&lt;meta http-equiv="Content-Type" content="text/html; '+
    'charset=UTF-8" /&gt;'+
    '&lt;/head&gt;'+
    '&lt;body&gt;'+
    '&lt;form action="/upload" method="post"&gt;'+
    '&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'+
    '&lt;input type="submit" value="Submit text" /&gt;'+
    '&lt;/form&gt;'+
    '&lt;/body&gt;'+
    '&lt;/html&gt;';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response) {
  console.log("Request handler 'upload' was called.");
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello Upload");
  response.end();
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				Now if this isn't going to win the Webby Awards, then I don'tknow what could. You should see this very simple form whenrequesting<a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>in your browser. If not, you probably didn't restart theapplication.
			</p>
			<p>
				I hear you: having view content right in the request handler isugly. However, I decided to not include that extra level ofabstraction (i.e., separating view and controller logic) inthis tutorial, because I think that it doesn't teach usanything worth knowing in the context of JavaScript or Node.js.
			</p>
			<p>
				Let's rather use the remaining screen space for a moreinteresting problem, that is, handling the POST requestthat will hit our <em>/upload</em> request handler when theuser submits this form.
			</p>
			<p>
				Now that we are becoming expert novices, we are no longersurprised by the fact that handling POST data is done in anon-blocking fashion, by using asynchronous callbacks.
			</p>
			<p>
				Which makes sense, because POST requests can potentially bevery large - nothing stops the user from entering text that ismultiple megabytes in size. Handling the whole bulk of data inone go would result in a blocking operation.
			</p>
			<p>
				To make the whole process non-blocking, Node.js serves our codethe POST data in small chunks, callbacks that are called uponcertain events. These events are <em>data</em> (an new chunk ofPOST data arrives) and <em>end</em> (all chunks have beenreceived).
			</p>
			<p>
				We need to tell Node.js which functions to call back to whenthese events occur. This is done by adding <em>listeners</em>to the <em>request</em> object that is passed to our<em>onRequest</em> callback whenever an HTTP request isreceived.
			</p>
			<p>
				This basically looks like this:
			</p>
<pre class="prettyprint lang-js">request.addListener("data", function(chunk) {
  // called when a new chunk of data was received
});

request.addListener("end", function() {
  // called when all chunks of data have been received
});
</pre>
			<p>
				The question arises where to implement this logic. We currentlycan access the <em>request</em> object in our server only - wedon't pass it on to the router and the request handlers, likewe did with the <em>response</em> object.
			</p>
			<p>
				In my opinion, it's an HTTP servers job to give the applicationall the data from a requests it needs to do its job. Therefore,I suggest we handle the POST data processing right in theserver and pass the final data on to the router and the requesthandlers, which then can decide what to do with it.
			</p>
			<p>
				Thus, the idea is to put the <em>data</em> and <em>end</em>event callbacks in the server, collecting all POST data chunksin the <em>data</em> callback, and calling the router uponreceiving the <em>end</em> event, while passing the collecteddata chunks on to the router, which in turn passes it on to therequest handlers.
			</p>
			<p>
				Here we go, starting with <em>server.js</em>:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var postData = "";
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    request.setEncoding("utf8");

    request.addListener("data", function(postDataChunk) {
      postData += postDataChunk;
      console.log("Received POST data chunk '"+
      postDataChunk + "'.");
    });

    request.addListener("end", function() {
      route(handle, pathname, response, postData);
    });

  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				We basically did three things here: First, we defined that weexpect the encoding of the received data to be UTF-8, we addedan event listener for the "data" event which step by stepfills our new <em>postData</em> variable whenever a new chunkof POST data arrives, and we moved the call to our router intothe <em>end</em> event callback to make sure it's only calledwhen all POST data is gathered. We also pass the POST data intothe router, because we are going to need it in our requesthandlers.
			</p>
			<p>
				Adding the console logging on every chunk that is receivedprobably is a bad idea for production code (megabytes of POSTdata, remember?), but makes sense to see what happens.
			</p>
			<p>
				I suggest playing around with this a bit. Put smallamounts of text into the textarea as well as lots of text, andyou will see that for the larger texts, the <em>data</em>callback is indeed called multiple times.
			</p>
			<p>
				Let's add even more awesome to our app. On the /upload page,we will display the received content. To make this possible, weneed to pass the <em>postData</em> on to the request handlers,in <em>router.js</em>:
			</p>
<pre class="prettyprint lang-js">function route(handle, pathname, response, postData) {
  console.log("About to route a request for " + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname](response, postData);
  } else {
    console.log("No request handler found for " + pathname);
    response.writeHead(404, {"Content-Type": "text/plain"});
    response.write("404 Not found");
    response.end();
  }
}

exports.route = route;
</pre>
			<p>
				And in <em>requestHandlers.js</em>, we include the data in ourresponse of the <em>upload</em> request handler:
			</p>
<pre class="prettyprint lang-js">function start(response, postData) {
  console.log("Request handler 'start' was called.");

  var body = '&lt;html&gt;'+
    '&lt;head&gt;'+
    '&lt;meta http-equiv="Content-Type" content="text/html; '+
    'charset=UTF-8" /&gt;'+
    '&lt;/head&gt;'+
    '&lt;body&gt;'+
    '&lt;form action="/upload" method="post"&gt;'+
    '&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'+
    '&lt;input type="submit" value="Submit text" /&gt;'+
    '&lt;/form&gt;'+
    '&lt;/body&gt;'+
    '&lt;/html&gt;';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log("Request handler 'upload' was called.");
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("You've sent: " + postData);
  response.end();
}

exports.start = start;
exports.upload = upload;
</pre>

			<p>
				That's it, we are now able to receive POST data and use it inour request handlers.
			</p>
			<p>
				One last thing for this topic: what we pass on to the routerand the request handlers is the complete body of our POSTrequest. We will probably want to consume the individual fieldsthat make up the POST data, in this case, the value of the<em>text</em> field.
			</p>
			<p>
				We already read about the <em>querystring</em> module, whichassists us with this:
			</p>
<pre class="prettyprint lang-js">var querystring = require("querystring");

function start(response, postData) {
  console.log("Request handler 'start' was called.");

  var body = '&lt;html&gt;'+
    '&lt;head&gt;'+
    '&lt;meta http-equiv="Content-Type" content="text/html; '+
    'charset=UTF-8" /&gt;'+
    '&lt;/head&gt;'+
    '&lt;body&gt;'+
    '&lt;form action="/upload" method="post"&gt;'+
    '&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'+
    '&lt;input type="submit" value="Submit text" /&gt;'+
    '&lt;/form&gt;'+
    '&lt;/body&gt;'+
    '&lt;/html&gt;';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log("Request handler 'upload' was called.");
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("You've sent the text: "+
  querystring.parse(postData).text);
  response.end();
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				Well, for a beginner's tutorial, that's all there is to sayabout handling POST data.
			</p>

			<h4>Handling file uploads</h4>
			<p>
				Let's tackle our final use case. Our plan was to allow users toupload an image file, and display the uploaded image in thebrowser.
			</p>
			<p>
				Back in the 90's this would have qualified as a business modelfor an IPO, today it must suffice to teach us two things: howto install external Node.js libraries, and how to make use ofthem in our own code.
			</p>
			<p>
				The external module we are going to use is<em>node-formidable</em> by Felix Geisend&ouml;rfer. It nicelyabstracts away all the nasty details of parsing incoming filedata. At the end of the day, handling incoming files is "only"about handling POST data - but the devil really <em>is</em> inthe	details here, and using a ready-made solution makes a lotof sense in this case.
			</p>
			<p>
				In order to make use of Felix' code, the according Node.jsmodule needs to be installed. Node.js ships with its ownpackage manager, dubbed <em>NPM</em>. It allows us to installexternal Node.js modules in a very convenient fashion. Given aworking Node.js installation, it boils down to issuing
			</p>
<pre class="prettyprint lang-bash">npm install formidable
</pre>
			<p>
				on our command line. If the following output ends with
			</p>
<pre class="prettyprint lang-bash">npm info build Success: formidable@1.0.2
npm ok
</pre>
			<p>
				then we are good to go.
			</p>
			<p>
				The <em>formidable</em> module is now available to our owncode - all we need to do is requiring it just like one of thebuilt-in modules we used earlier:
			</p>
<pre class="prettyprint lang-js">var formidable = require("formidable");
</pre>
			<p>
				The metaphor formidable uses is that of a form being submittedvia HTTP POST, making it parseable in Node.js. All we need todo is create a new <em>IncomingForm</em>, which is anabstraction of this	submitted form, and which can then be usedto parse the <em>request</em> object of our HTTP server for thefields and files that were submitted through this form.
			</p>
			<p>
				The example code from the node-formidable project page showshow the different parts play together:
			</p>
<pre class="prettyprint lang-js">var formidable = require('formidable'),
    http = require('http'),
    sys = require('sys');

http.createServer(function(req, res) {
  if (req.url == '/upload' && req.method.toLowerCase() == 'post') {
    // parse a file upload
    var form = new formidable.IncomingForm();
    form.parse(req, function(err, fields, files) {
      res.writeHead(200, {'content-type': 'text/plain'});
      res.write('received upload:\n\n');
      res.end(sys.inspect({fields: fields, files: files}));
    });
    return;
  }

  // show a file upload form
  res.writeHead(200, {'content-type': 'text/html'});
  res.end(
    '&lt;form action="/upload" enctype="multipart/form-data" '+
    'method="post"&gt;'+
    '&lt;input type="text" name="title"&gt;&lt;br&gt;'+
    '&lt;input type="file" name="upload" multiple="multiple"&gt;&lt;br&gt;'+
    '&lt;input type="submit" value="Upload"&gt;'+
    '&lt;/form&gt;'
  );
}).listen(8888);
</pre>
		<p>
				
			If we put this code into a file and execute it through
			<em>node</em>, we are able to submit a simple form, including a
			file upload, and see how the <em>files</em> object, which is passed
			to the callback defined in the <em>form.parse</em> call, is
			structured:
		</p>
<pre class="lang-js">received upload:

{ fields: { title: 'Hello World' },
  files:
   { upload:
      { size: 1558,
        path: '/tmp/1c747974a27a6292743669e91f29350b',
        name: 'us-flag.png',
        type: 'image/png',
        lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT,
        _writeStream: [Object],
        length: [Getter],
        filename: [Getter],
        mime: [Getter] } } }
</pre>

			<p>
				In order to make our use case happen, what we need to do isto include the form-parsing logic of formidable into our codestructure, plus we will need to find out how to serve thecontent of the uploaded file (which is saved into the<em>/tmp</em> folder) to a requesting browser.
			</p>
			<p>
				Let's tackle the latter one first: if there is an image file onour local hardrive, how do we serve it to a requesting browser?
			</p>
			<p>
				We are obviously going to read the contents of this file intoour Node.js server, and unsurprisingly, there is a module forthat - it's called <em>fs</em>.
			</p>
			<p>
				Let's add another request handler for the URL <em>/show</em>,which will hardcodingly display the contents of the file<em>/tmp/test.png</em>. It of course makes a lot of sense tosave a real png image file to this location first.
			</p>
			<p>
				We are going to modify <em>requestHandlers.js</em> as follows:
			</p>
<pre class="prettyprint lang-js">var querystring = require("querystring"),
    fs = require("fs");

function start(response, postData) {
  console.log("Request handler 'start' was called.");

  var body = '&lt;html&gt;'+
    '&lt;head&gt;'+
    '&lt;meta http-equiv="Content-Type" '+
    'content="text/html; charset=UTF-8" /&gt;'+
    '&lt;/head&gt;'+
    '&lt;body&gt;'+
    '&lt;form action="/upload" method="post"&gt;'+
    '&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'+
    '&lt;input type="submit" value="Submit text" /&gt;'+
    '&lt;/form&gt;'+
    '&lt;/body&gt;'+
    '&lt;/html&gt;';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log("Request handler 'upload' was called.");
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("You've sent the text: "+
  querystring.parse(postData).text);
  response.end();
}

function show(response, postData) {
  console.log("Request handler 'show' was called.");
  fs.readFile("/tmp/test.png", "binary", function(error, file) {
    if(error) {
      response.writeHead(500, {"Content-Type": "text/plain"});
      response.write(error + "\n");
      response.end();
    } else {
      response.writeHead(200, {"Content-Type": "image/png"});
      response.write(file, "binary");
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;
</pre>

			<p>
				We also need to map this new request handler to the URL<em>/show</em> in file <em>index.js</em>:
			</p>
<pre class="prettyprint lang-js">var server = require("./server");
var router = require("./router");
var requestHandlers = require("./requestHandlers");

var handle = {}
handle["/"] = requestHandlers.start;
handle["/start"] = requestHandlers.start;
handle["/upload"] = requestHandlers.upload;
handle["/show"] = requestHandlers.show;

server.start(router.route, handle);
</pre>

			<p>
				By restarting the server and opening<a href="http://localhost:8888/show" rel="nofollow">http://localhost:8888/show</a>in the browser, the image file saved at <em>/tmp/test.png</em>should be displayed.
			</p>
			<p>
				Fine. All we need to do now is<ul>	<li>		add a file upload element to the form which is served		at <em>/start</em>,	</li>	<li>		integrate node-formidable into the <em>upload</em>		request handler, in order to save the uploaded file to		<em>/tmp/test.png</em>,	</li>	<li>		embed the uploaded image into the HTML output of the		<em>/upload</em> URL.	</li></ul>
			</p>
			<p>
				Step 1 is simple. We need to add an encoding type of<em>multipart/form-data</em> to our HTML form, remove thetextarea, add a file upload input field, and change the submitbutton text to "Upload file". Let's do just that in file<em>requestHandlers.js</em>:
			</p>
<pre class="prettyprint lang-js">var querystring = require("querystring"),
    fs = require("fs");

function start(response, postData) {
  console.log("Request handler 'start' was called.");

  var body = '&lt;html&gt;'+
    '&lt;head&gt;'+
    '&lt;meta http-equiv="Content-Type" '+
    'content="text/html; charset=UTF-8" /&gt;'+
    '&lt;/head&gt;'+
    '&lt;body&gt;'+
    '&lt;form action="/upload" enctype="multipart/form-data" '+
    'method="post"&gt;'+
    '&lt;input type="file" name="upload"&gt;'+
    '&lt;input type="submit" value="Upload file" /&gt;'+
    '&lt;/form&gt;'+
    '&lt;/body&gt;'+
    '&lt;/html&gt;';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response, postData) {
  console.log("Request handler 'upload' was called.");
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("You've sent the text: "+
  querystring.parse(postData).text);
  response.end();
}

function show(response, postData) {
  console.log("Request handler 'show' was called.");
  fs.readFile("/tmp/test.png", "binary", function(error, file) {
    if(error) {
      response.writeHead(500, {"Content-Type": "text/plain"});
      response.write(error + "\n");
      response.end();
    } else {
      response.writeHead(200, {"Content-Type": "image/png"});
      response.write(file, "binary");
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;
</pre>
			<p>
				Great. The next step is a bit more complex of course. The firstproblem is: we want to handle the file upload in our<em>upload</em> request handler, and there, we will need to passthe <em>request</em> object to the <em>form.parse</em> call ofnode-formidable.
			</p>
			<p>
				But all we have is the <em>response</em> objectand the <em>postData</em> array. Sad panda. Looks like we will haveto pass the <em>request</em> object all the way from the server tothe router to the request handler. There may be more elegantsolutions, but this approach should do the job for now.
			</p>
			<p>
				And while we are at it, let's remove the whole <em>postData</em> stuff inour server and request handlers - we won't need it for handling thefile upload, and it even raises a problem: we already "consumed"the <em>data</em> events of the <em>request</em> object in theserver, which means that <em>form.parse</em>, which also needs toconsume those events, wouldn't receive any more data from them(because Node.js doesn't buffer any data).
			</p>
			<p>
				Let's start with <em>server.js</em> - we remove the postDatahandling and the <em>request.setEncoding</em> line (which is goingto be handled by node-formidable itself), and we pass<em>request</em> to the router instead:

			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");
    route(handle, pathname, response, request);
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>

		<p>
				
			Next comes <em>router.js</em> - we don't need to pass <em>postData</em>
			on anymore, and instead pass <em>request</em>:
		</p>
<pre class="prettyprint lang-js">function route(handle, pathname, response, request) {
  console.log("About to route a request for " + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname](response, request);
  } else {
    console.log("No request handler found for " + pathname);
    response.writeHead(404, {"Content-Type": "text/html"});
    response.write("404 Not found");
    response.end();
  }
}

exports.route = route;
</pre>

			<p>
				Now, the <em>request</em> object can be used in our <em>upload</em>request handler function. node-formidable will handle the detailsof saving the uploaded file to a local file within <em>/tmp</em>,but we need to make sure that this file is renamed to<em>/tmp/test.png</em> ourselves. Yes, we keep things really simpleand assume that only PNG images will be uploaded.
			</p>
			<p>
				For now, <em>fs.renameSync(path1, path2)</em> will do the job.Beware! As the name implies, it works synchronous, thus if therename operation should be expensive and take a long time, it willlead to blocking. Let's just agree that we are all grown-ups hereand know what we are doing.
			</p>
			<p>
				Let's put the pieces of managing the uploaded file and renaming ittogether now, in file <em>requestHandlers.js</em>:
			</p>
<pre class="prettyprint lang-js">var querystring = require("querystring"),
    fs = require("fs"),
    formidable = require("formidable");

function start(response) {
  console.log("Request handler 'start' was called.");

  var body = '&lt;html&gt;'+
    '&lt;head&gt;'+
    '&lt;meta http-equiv="Content-Type" content="text/html; '+
    'charset=UTF-8" /&gt;'+
    '&lt;/head&gt;'+
    '&lt;body&gt;'+
    '&lt;form action="/upload" enctype="multipart/form-data" '+
    'method="post"&gt;'+
    '&lt;input type="file" name="upload" multiple="multiple"&gt;'+
    '&lt;input type="submit" value="Upload file" /&gt;'+
    '&lt;/form&gt;'+
    '&lt;/body&gt;'+
    '&lt;/html&gt;';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response, request) {
  console.log("Request handler 'upload' was called.");

  var form = new formidable.IncomingForm();
  console.log("about to parse");
  form.parse(request, function(error, fields, files) {
    console.log("parsing done");
    fs.renameSync(files.upload.path, "/tmp/test.png");
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("received image:&lt;br/&gt;");
    response.write("&lt;img src='/show' /&gt;");
    response.end();
  });
}

function show(response) {
  console.log("Request handler 'show' was called.");
  fs.readFile("/tmp/test.png", "binary", function(error, file) {
    if(error) {
      response.writeHead(500, {"Content-Type": "text/plain"});
      response.write(error + "\n");
      response.end();
    } else {
      response.writeHead(200, {"Content-Type": "image/png"});
      response.write(file, "binary");
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;
</pre>
			<p>
				And that's it. Restart the server, and the complete use case willbe available. Select a local PNG image from your hardrive, uploadit to the server, and have it displayed in the web page.
			</p>

			<h2>Conclusion and outlook</h2>
			<p>
				Congratulations, our mission is accomplished! We wrote a simpleyet full-fledged Node.js web application. We talked aboutserver-side JavaScript, functional programming, blocking andnon-blocking operations, callbacks, events, custom, internaland external modules, and a lot more.
			</p>
			<p>
				Of course, there's a lot of stuff we did not talk about:how to talk to a database, how to write unit tests, how tocreate external modules that are installable via NPM, or evensomething simple like how to handle GET requests.
			</p>
			<p>
				But that's the fate of every book aimed at beginners - it can'ttalk about every single aspect in every single detail.
			</p>
			<p>
				The good news is, the Node.js community is extremly vibrant(think of an ADHD kid on caffeine, but in a positive way),which means there are a lot of resources out there, and a lotof places to get your questions answered. The<a href="https://github.com/joyent/node/wiki">Node.js community wiki</a>and <a href="http://www.nodecloud.org/">the NodeCloud directory</a>are probably the best starting points for more information.
			</p>
		</div>




		
		<div id="workinprogressnote">
			<p>
				This document was last updated on<strong>Sunday, July 10, 2011 at 3:52 AM EDT</strong>.
			</p>
			<p>
				The best way to stay informed about updates is to follow<br /><a href="http://twitter.com/manuelkiessling">@ManuelKiessling on Twitter</a>.
			</p>
		</div>


		<div id="praise">
			<div class="praise"><div class="comment">	"I love nodebeginner.org - concise, direct to the point and	even enjoyable to read."</div><div class="author">Gojko Adzic, author of <em>Specification by Example</em> and <em>Bridging the Communication Gap</em></div>
			</div>
			<div class="praise"><div class="comment">	"This is one of the best tutorials I've read.	As a former Java coder, I've always found JavaScript	to be a black art, but you have really simplified	things with this tutorial."</div><div class="author">Erskine, from the comments</div>
			</div>
			<div class="praise"><div class="comment">	"This is one of the few beginner articles I made it all the	way through because of how well it's written."</div><div class="author">	Paul Gibler, from the comments</div>
			</div>
			<div class="praise"><div class="comment">	"Indispensable."</div><div class="author">	@lecolibrilibre, on Twitter</div>
			</div>
			<div class="praise"><div class="comment">	"I just wanted to drop you a note to say thank you for	writing such an excellent introduction to node. Your book's	explanation is fantastic, and I can't wait for you to	finish it!"</div><div class="author">	Seth McLaughlin, via eMail</div>
			</div>
		</div>

		<div id="donate">
			<p>
				<em>The Node Beginner Book</em> is and will always be available for free.<br />Furthermore, no money is needed to keep the project alive and progressing.<br />But if you would like to support the author, you can do so using Flattr or PayPal:
			</p>
			<div id="flattr"><a class="FlattrButton" style="display:none;" href="http://www.nodebeginner.org"></a>
			</div>
			<div id="paypal"><form action="https://www.paypal.com/cgi-bin/webscr" method="post">	<fieldset>		<input type="hidden" name="cmd" value="_s-xclick" />		<input type="hidden" name="hosted_button_id" value="AWJS7PD37SQ5G" />		<input type="image" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_US/i/btn/btn_donateCC_LG.gif" name="submit" alt="PayPal - The safer, easier way to pay online!" />		<img alt="" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/de_DE/i/scr/pixel.gif" width="1" height="1" />	</fieldset></form>
			</div>
			<p>
				Or, have a look at <a href="/buy/">the eBook version (Kindle, ePub, PDF)</a>,<br />which is available for $4.99 via Leanpub.
			</p>
		</div>

		<div id="disqus_thread"></div>
		<script type="text/javascript">
			var disqus_shortname = 'nodebeginner';
			var disqus_identifier = 'nodebeginner-book';
			var disqus_url = 'http://www.nodebeginner.org/';

			(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			})();
		</script>

		<div id="footer">
			<p id="ccimage"><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
			</p>
			<p>
				<span xmlns:dct="http://purl.org/dc/terms/">The Node Beginner Book</span>by<a xmlns:cc="http://creativecommons.org/ns#" href="http://manuel.kiessling.net" rel="cc:attributionURL">Manuel Kiessling</a>is licensed under a<br /><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.<br />Permissions beyond the scope of this license may be available at <a xmlns:cc="http://creativecommons.org/ns#" href="mailto:manuel@kiessling.net" rel="cc:morePermissions">manuel@kiessling.net</a>.
			</p>
		</div>
	</body>
</html>
